"""
    set_axes_equal(ax)

Set the axes of a 3D plot to be equal in scale.
"""
function set_axes_equal(ax)
    limits = [get_xlim(ax), get_ylim(ax), get_zlim(ax)]
    
    # Find the max range for all axes
    max_range = maximum(abs.(diff.(limits))) / 2.0
    
    # Calculate midpoints for all axes
    mid_x = mean(limits[1])
    mid_y = mean(limits[2])
    mid_z = mean(limits[3])
    
    # Set limits to be centered and equal in range
    xlims!(ax, mid_x - max_range, mid_x + max_range)
    ylims!(ax, mid_y - max_range, mid_y + max_range)
    zlims!(ax, mid_z - max_range, mid_z + max_range)
end

"""
    plot_3d_vector(v, origin=[0, 0, 0]; plot_arrow=true, plot_line=false, ax=nothing, color="b", elev=45, azim=-45)

Plot a 3D vector with optional arrow or line representation.
"""
function plot_3d_vector(v, origin=[0, 0, 0]; plot_arrow=true, plot_line=false, ax=nothing, color="b", elev=45, azim=-45)
    # Create a new figure and 3D axes if none are provided
    if ax === nothing
        fig = plot3d()
        ax = fig
    end
    
    if plot_arrow && !plot_line
        # Plot the vector as an arrow
        quiver!(ax, [origin[1]], [origin[2]], [origin[3]], 
                quiver=([v[1]], [v[2]], [v[3]]),
                color=color, linewidth=2)
    elseif !plot_arrow && plot_line
        plot!(ax, [origin[1], v[1]], [origin[2], v[2]], [origin[3], v[3]], color=color)
    else
        r = v + origin
        scatter!(ax, [r[1]], [r[2]], [r[3]], color=color)
    end
    
    view!(ax, elev=elev, azim=azim)
    
    return ax
end

"""
    bfield_from_thin_straight_wire(x, y, z, p1, p2, current; plot_wire=false, elev=45, azim=-45, ax=nothing, return_axes=false)

Calculate the magnetic field generated by a thin, straight current-carrying wire.
"""
function bfield_from_thin_straight_wire(x, y, z, p1, p2, current; plot_wire=false, elev=45, azim=-45, ax=nothing, return_axes=false)
    # Convert input points to arrays
    p1 = collect(p1)  # three vector defining beginning of current element
    p2 = collect(p2)  # three vector defining end of current element
    
    # Ensure the wire is specified by two distinct points
    @assert norm(p2 - p1) > 0 "Line must be specified by 2 distinct points"
    
    # Create a grid of observation points
    P = cat(x, y, z, dims=4)  # Shape (Nx, Ny, Nz, 3)
    
    # Vector from p1 to p2 (the wire direction)
    L = p2 - p1
    Lhat = L / norm(L)  # Unit vector along the wire
    
    # Project P onto the line p1p2 to find the nearest point on the line to P
    tmin = dot.(P .- p1, Lhat)  # Shape (Nx, Ny, Nz)
    lmin = p1 .+ tmin .* Lhat  # Shape (Nx, Ny, Nz, 3)
    
    # Calculate the vectors e1, e2, e3
    e1 = Lhat  # Shape (3,)
    e2 = P .- lmin
    e2_norm = norm.(e2, dims=4)
    e2 = e2 ./ e2_norm  # Normalize e2
    e3 = cross.(e1, e2)  # Cross product to find e3
    
    # Calculate x1 and x2
    x1 = dot.(p1 .- lmin, e1)  # Shape (Nx, Ny, Nz)
    x2 = dot.(p2 .- lmin, e1)  # Shape (Nx, Ny, Nz)
    
    # Distance R from the line to the point P
    R = dropdims(e2_norm, dims=4)  # Shape (Nx, Ny, Nz)
    
    # Calculate the magnetic field magnitude B0
    B0 = (mu_0 * current / (4π * R)) .* (
        x2 ./ sqrt.(x2.^2 .+ R.^2) .- x1 ./ sqrt.(x1.^2 .+ R.^2)
    )  # Shape (Nx, Ny, Nz)
    
    # Final magnetic field vector at each point
    B = B0 .* e3  # Shape (Nx, Ny, Nz, 3)
    
    if plot_wire
        ax = plot_3d_vector(p2 - p1, p1, plot_arrow=true, color="k", elev=45, azim=-45, ax=ax)
        xlabel!(ax, "x (m)")
        ylabel!(ax, "y (m)")
        zlabel!(ax, "z (m)")
    end
    
    if plot_wire && return_axes
        return B[:,:,:,1], B[:,:,:,2], B[:,:,:,3], ax
    else
        return B[:,:,:,1], B[:,:,:,2], B[:,:,:,3]
    end
end

"""
    Ry(angle)

Defines a rotation around the +y direction.
"""
function Ry(angle)
    C = cos(angle)
    S = sin(angle)
    
    return [C 0 S; 0 1 0; -S 0 C]
end

"""
    Rx(angle)

Defines a rotation around the +x direction.
"""
function Rx(angle)
    C = cos(angle)
    S = sin(angle)
    
    return [1 0 0; 0 C -S; 0 S C]
end

"""
    Rz(angle)

Defines a rotation around the +z direction.
"""
function Rz(angle)
    C = cos(angle)
    S = sin(angle)
    
    return [C -S 0; S C 0; 0 0 1]
end

"""
    get_rotation_matrix(pitch, yaw, tilt)

Defines a general 3D rotation in terms of the orientation angles theta, phi, psi.
"""
function get_rotation_matrix(pitch, yaw, tilt)
    pitch = isnothing(pitch) ? 0 : pitch
    yaw = isnothing(yaw) ? 0 : yaw
    tilt = isnothing(tilt) ? 0 : tilt
    
    ry = Ry(pitch)
    rx = Rx(yaw)
    rz = Rz(tilt)
    
    return ry * rx * rz
end

"""
    bfield_from_thin_rectangular_coil(X, Y, Z, a, b, y0, current; plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Calculate the magnetic field generated by a thin, rectangular current-carrying coil.
"""
function bfield_from_thin_rectangular_coil(X, Y, Z, a, b, y0, current; plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    p1 = [-a/2, y0, -b/2]
    p2 = [+a/2, y0, -b/2]
    p3 = [+a/2, y0, +b/2]
    p4 = [-a/2, y0, +b/2]
    
    if !isnothing(pitch) || !isnothing(yaw) || !isnothing(tilt)
        @assert isnothing(rotation_matrix) "Cannot specify the rotation matrix and rotation angles at the same time"
        rotation_matrix = get_rotation_matrix(pitch, yaw, tilt)
    end
    
    if !isnothing(rotation_matrix)
        p1 = rotation_matrix * p1
        p2 = rotation_matrix * p2
        p3 = rotation_matrix * p3
        p4 = rotation_matrix * p4
    end
    
    if !isnothing(offset)
        p1 = p1 + offset
        p2 = p2 + offset
        p3 = p3 + offset
        p4 = p4 + offset
    end
    
    Bx1, By1, Bz1 = bfield_from_thin_straight_wire(X, Y, Z, p1, p2, current, plot_wire=false, elev=elev, azim=azim)
    Bx2, By2, Bz2 = bfield_from_thin_straight_wire(X, Y, Z, p2, p3, current, plot_wire=false, elev=elev, azim=azim)
    Bx3, By3, Bz3 = bfield_from_thin_straight_wire(X, Y, Z, p3, p4, current, plot_wire=false, elev=elev, azim=azim)
    Bx4, By4, Bz4 = bfield_from_thin_straight_wire(X, Y, Z, p4, p1, current, plot_wire=false, elev=elev, azim=azim)
    
    if plot_wire
        ax = plot_3d_vector(p2 - p1, p1, plot_arrow=true, color="k", elev=elev, azim=azim, ax=ax)
        ax = plot_3d_vector(p3 - p2, p2, plot_arrow=true, color="k", elev=elev, azim=azim, ax=ax)
        ax = plot_3d_vector(p4 - p3, p3, plot_arrow=true, color="k", elev=elev, azim=azim, ax=ax)
        ax = plot_3d_vector(p1 - p4, p4, plot_arrow=true, color="k", elev=elev, azim=azim, ax=ax)
        
        xlabel!(ax, "x (m)")
        ylabel!(ax, "y (m)")
        zlabel!(ax, "z (m)")
    end
    
    return (Bx1 + Bx2 + Bx3 + Bx4, By1 + By2 + By3 + By4, Bz1 + Bz2 + Bz3 + Bz4)
end

"""
    bfield_from_thin_rectangular_corrector(X, Y, Z, a, b, h, current; plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Calculate the magnetic field generated by a thin, rectangular air-core corrector magnet.
"""
function bfield_from_thin_rectangular_corrector(X, Y, Z, a, b, h, current; plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    Bx1, By1, Bz1 = bfield_from_thin_rectangular_coil(X, Y, Z, a, b, -h/2, current, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    if plot_wire
        ax = current_axis()
    end
    
    Bx2, By2, Bz2 = bfield_from_thin_rectangular_coil(X, Y, Z, a, b, +h/2, current, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    return (Bx1 + Bx2, By1 + By2, Bz1 + Bz2)
end

"""
    rotate_around_e3(theta)

Generate a 3D rotation matrix for a rotation around the z-axis (e3) by an angle theta.
"""
function rotate_around_e3(theta)
    C, S = cos(theta), sin(theta)
    
    return [C -S 0; S C 0; 0 0 1]
end

"""
    get_arc_vectors(h, R, theta, npts=100, arc_e3=[0, 0, 1])

Calculate the position vectors along a circular arc in 3D space.
"""
function get_arc_vectors(h, R, theta, npts=100, arc_e3=[0, 0, 1])
    phi = (π - theta) / 2
    
    arc_e1 = rotate_around_e3(phi) * [1, 0, 0]
    
    @assert isapprox(dot(arc_e1, arc_e3), 0)
    
    ths = range(0, theta, length=npts)
    
    ps = zeros(length(ths), 3)
    
    for (ii, th) in enumerate(ths)
        ps[ii,:] = [0, 0, h] + R * rotate_around_e3(th) * arc_e1
    end
    
    return ps
end

"""
    plot_arc_vectors(ps; color="k", elev=45, azim=-45, ax=nothing)

Plot vectors along an arc.
"""
function plot_arc_vectors(ps; color="k", elev=45, azim=-45, ax=nothing)
    for ii in 1:size(ps,1)-1
        p1 = ps[ii,:]
        p2 = ps[ii+1,:]
        
        if ax === nothing
            ax = plot_3d_vector(p2 - p1, p1, color=color, elev=elev, azim=azim, plot_arrow=true, plot_line=false)
        else
            ax = plot_3d_vector(p2 - p1, p1, color=color, elev=elev, azim=azim, plot_arrow=true, plot_line=false, ax=ax)
        end
    end
    
    return ax
end

"""
    bfield_from_thin_wire_arc(X, Y, Z, h, R, theta; npts=100, current=1, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, yaw=nothing, pitch=nothing, tilt=nothing)

Calculate the magnetic field generated by a thin wire arc.
"""
function bfield_from_thin_wire_arc(X, Y, Z, h, R, theta; npts=100, current=1, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, yaw=nothing, pitch=nothing, tilt=nothing)
    ps = get_arc_vectors(h, R, theta, npts=npts)
    
    if !isnothing(pitch) || !isnothing(yaw) || !isnothing(tilt)
        @assert isnothing(rotation_matrix) "Cannot specify the rotation matrix and rotation angles at the same time"
        rotation_matrix = get_rotation_matrix(pitch, yaw, tilt)
    end
    
    if !isnothing(rotation_matrix)
        for ii in 1:size(ps,1)
            ps[ii,:] = rotation_matrix * ps[ii,:]
        end
    end
    
    if !isnothing(offset)
        for ii in 1:size(ps,1)
            ps[ii,:] = ps[ii,:] + offset
        end
    end
    
    Bx = zeros(size(X))
    By = zeros(size(Y))
    Bz = zeros(size(Z))
    
    for ii in 1:size(ps,1)-1
        p1 = ps[ii,:]
        p2 = ps[ii+1,:]
        
        if ii == 1 && plot_wire
            ax = current_axis()
        end
        
        Bxii, Byii, Bzii = bfield_from_thin_straight_wire(X, Y, Z, p1, p2, current, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax)
        
        Bx += Bxii
        By += Byii
        Bz += Bzii
    end
    
    return Bx, By, Bz
end

"""
    bfield_from_thin_saddle_coil(X, Y, Z, L, R, theta, current; npts=10, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Calculate the magnetic field generated by a thin saddle coil.
"""
function bfield_from_thin_saddle_coil(X, Y, Z, L, R, theta, current; npts=10, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    phi = (π - theta) / 2
    
    Bx = zeros(size(X))
    By = zeros(size(Y))
    Bz = zeros(size(Z))
    
    BxA1, ByA1, BzA1 = bfield_from_thin_wire_arc(X, Y, Z, -L/2, R, +theta, npts=npts, current=current, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    if plot_wire
        ax = current_axis()
    end
    
    BxA2, ByA2, BzA2 = bfield_from_thin_wire_arc(X, Y, Z, +L/2, R, -theta, npts=npts, current=current, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim, pitch=pitch, yaw=yaw, tilt=tilt)
    
    Bx += BxA1 + BxA2
    By += ByA1 + ByA2
    Bz += BzA1 + BzA2
    
    # Straight section 1
    p11 = [R * cos(phi), R * sin(phi), +L/2]
    p21 = [R * cos(phi), R * sin(phi), -L/2]
    
    # Straight section 2
    p12 = [-R * cos(phi), R * sin(phi), -L/2]
    p22 = [-R * cos(phi), R * sin(phi), +L/2]
    
    if !isnothing(pitch) || !isnothing(yaw) || !isnothing(tilt)
        @assert isnothing(rotation_matrix) "Cannot specify the rotation matrix and rotation angles at the same time"
        rotation_matrix = get_rotation_matrix(pitch, yaw, tilt)
    end
    
    if !isnothing(rotation_matrix)
        p11 = rotation_matrix * p11
        p21 = rotation_matrix * p21
        p12 = rotation_matrix * p12
        p22 = rotation_matrix * p22
    end
    
    if !isnothing(offset)
        p11 = p11 + offset
        p21 = p22 + offset
        p12 = p12 + offset
        p22 = p22 + offset
    end
    
    BxS1, ByS1, BzS1 = bfield_from_thin_straight_wire(X, Y, Z, p11, p21, current=current, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)
    BxS2, ByS2, BzS2 = bfield_from_thin_straight_wire(X, Y, Z, p12, p22, current=current, plot_wire=plot_wire, ax=ax, elev=elev, azim=azim)
    
    Bx += BxS1 + BxS2
    By += ByS1 + ByS2
    Bz += BzS1 + BzS2
    
    return (Bx, By, Bz)
end

"""
    bfield_from_thin_saddle_corrector(X, Y, Z, L, R, theta, current; npts=10, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Calculate the magnetic field generated by a thin saddle corrector.
"""
function bfield_from_thin_saddle_corrector(X, Y, Z, L, R, theta, current; npts=10, plot_wire=false, elev=45, azim=-45, ax=nothing, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    Bx1, By1, Bz1 = bfield_from_thin_saddle_coil(X, Y, Z, +L, +R, theta, current, npts=npts, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    if plot_wire
        ax = current_axis()
    end
    
    Bx2, By2, Bz2 = bfield_from_thin_saddle_coil(X, Y, Z, -L, -R, theta, current, npts=npts, plot_wire=plot_wire, elev=elev, azim=azim, ax=ax, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    return Bx1 + Bx2, By1 + By2, Bz1 + Bz2
end

"""
    make_rectangular_dipole_corrector_fieldmesh(; a=nothing, b=nothing, h=nothing, current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Generate a 3D magnetic field mesh for a rectangular dipole corrector magnet.
"""
function make_rectangular_dipole_corrector_fieldmesh(; a=nothing, b=nothing, h=nothing, current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    xs = range(xmin, xmax, length=nx)
    ys = range(ymin, ymax, length=ny)
    zs = range(zmin, zmax, length=nz)
    
    X, Y, Z = meshgrid(xs, ys, zs)
    
    Bx, By, Bz = bfield_from_thin_rectangular_corrector(X, Y, Z, a, b, h, current, plot_wire=true, offset=offset, rotation_matrix=rotation_matrix, pitch=pitch, yaw=yaw, tilt=tilt)
    
    dx = (xmax - xmin) / (nx - 1)
    dy = (ymax - ymin) / (ny - 1)
    dz = (zmax - zmin) / (nz - 1)
    
    attrs = Dict(
        "gridOriginOffset" => (xs[1], ys[1], zs[1]),
        "gridSpacing" => (dx, dy, dz),
        "gridSize" => size(Bx),
        "eleAnchorPt" => "center",
        "gridGeometry" => "rectangular",
        "axisLabels" => ("x", "y", "z"),
        "gridLowerBound" => (0, 0, 0),
        "harmonic" => 0,
        "fundamentalFrequency" => 0
    )
    
    components = Dict(
        "magneticField/x" => Bx,
        "magneticField/y" => By,
        "magneticField/z" => Bz
    )
    
    data = Dict("attrs" => attrs, "components" => components)
    
    return FieldMesh(data=data)
end

"""
    make_saddle_dipole_corrector_fieldmesh(; R=nothing, L=nothing, theta=nothing, current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, npts=20, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Generate a 3D magnetic field mesh for a saddle dipole corrector.
"""
function make_saddle_dipole_corrector_fieldmesh(; R=nothing, L=nothing, theta=nothing, current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, npts=20, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    xs = range(xmin, xmax, length=nx)
    ys = range(ymin, ymax, length=ny)
    zs = range(zmin, zmax, length=nz)
    
    X, Y, Z = meshgrid(xs, ys, zs)
    
    Bx, By, Bz = bfield_from_thin_saddle_corrector(X, Y, Z, L, R, theta, npts=npts, current=current, plot_wire=plot_wire, pitch=pitch, yaw=yaw, tilt=tilt)
    
    if plot_wire
        ax = current_axis()
        set_axes_equal(ax)
    end
    
    dx = (xmax - xmin) / (nx - 1)
    dy = (ymax - ymin) / (ny - 1)
    dz = (zmax - zmin) / (nz - 1)
    
    shape = size(Bx)
    
    attrs = Dict(
        "gridOriginOffset" => (xs[1], ys[1], zs[1]),
        "gridSpacing" => (dx, dy, dz),
        "gridSize" => shape,
        "eleAnchorPt" => "center",
        "gridGeometry" => "rectangular",
        "axisLabels" => ("x", "y", "z"),
        "gridLowerBound" => (0, 0, 0),
        "harmonic" => 0,
        "fundamentalFrequency" => 0
    )
    
    components = Dict(
        "magneticField/x" => Bx,
        "magneticField/y" => By,
        "magneticField/z" => Bz
    )
    
    data = Dict("attrs" => attrs, "components" => components)
    
    return FieldMesh(data=data)
end

"""
    make_dipole_corrector_fieldmesh(; current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, mode="rectangular", a=nothing, b=nothing, h=nothing, R=nothing, L=nothing, theta=nothing, npts=nothing, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)

Generate a 3D magnetic field mesh for a dipole corrector based on either a rectangular or saddle coil design.
"""
function make_dipole_corrector_fieldmesh(; current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, mode="rectangular", a=nothing, b=nothing, h=nothing, R=nothing, L=nothing, theta=nothing, npts=nothing, plot_wire=false, offset=nothing, rotation_matrix=nothing, pitch=nothing, yaw=nothing, tilt=nothing)
    if mode == "rectangular"
        if isnothing(a) || isnothing(b) || isnothing(h)
            error("Parameters 'a', 'b', and 'h' must be provided for rectangular mode.")
        end
        
        f = 0.99
        
        if isnothing(xmin)
            xmin = -f * a
        end
        
        if isnothing(ymin)
            ymin = -f * h / 2
        end
        
        if isnothing(zmin)
            zmin = -5 * b
        end
        
        if isnothing(xmax)
            xmax = +f * a
        end
        
        if isnothing(ymax)
            ymax = +f * h / 2
        end
        
        if isnothing(zmax)
            zmax = +5 * b
        end
        
        return make_rectangular_dipole_corrector_fieldmesh(
            a=a, b=b, h=h, current=current,
            xmin=xmin, xmax=xmax, nx=nx,
            ymin=ymin, ymax=ymax, ny=ny,
            zmin=zmin, zmax=zmax, nz=nz,
            plot_wire=plot_wire, offset=offset,
            rotation_matrix=rotation_matrix,
            pitch=pitch, yaw=yaw, tilt=tilt
        )
    elseif mode == "saddle"
        if isnothing(xmin)
            xmin = -R
        end
        
        if isnothing(ymin)
            ymin = -R
        end
        
        if isnothing(zmin)
            zmin = -5 * L / 2
        end
        
        if isnothing(xmax)
            xmax = +R
        end
        
        if isnothing(ymax)
            ymax = +R
        end
        
        if isnothing(zmax)
            zmax = +5 * L / 2
        end
        
        if isnothing(R) || isnothing(L) || isnothing(theta)
            error("Parameters 'R', 'L', and 'theta' must be provided for saddle mode.")
        end
        
        return make_saddle_dipole_corrector_fieldmesh(
            R=R, L=L, theta=theta, current=current,
            xmin=xmin, xmax=xmax, nx=nx,
            ymin=ymin, ymax=ymax, ny=ny,
            zmin=zmin, zmax=zmax, nz=nz,
            npts=npts, plot_wire=plot_wire,
            offset=offset, rotation_matrix=rotation_matrix,
            pitch=pitch, yaw=yaw, tilt=tilt
        )
    else
        error("Invalid mode. Choose either 'rectangular' or 'saddle'.")
    end
end

"""
    make_thin_straight_wire_fieldmesh(p1, p2; current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, plot_wire=false)

Generate a 3D magnetic field mesh for a thin, straight, current-carrying wire.
"""
function make_thin_straight_wire_fieldmesh(p1, p2; current=1, xmin=nothing, xmax=nothing, nx=101, ymin=nothing, ymax=nothing, ny=101, zmin=nothing, zmax=nothing, nz=101, plot_wire=false)
    @assert !isnothing(xmin) "No xmin specified"
    @assert !isnothing(ymin) "No ymin specified"
    @assert !isnothing(zmin) "No zmin specified"
    
    @assert !isnothing(xmax) "No xmax specified"
    @assert !isnothing(ymax) "No ymax specified"
    @assert !isnothing(zmax) "No zmax specified"
    
    @assert !isnothing(nx) "No nx specified"
    @assert !isnothing(ny) "No ny specified"
    @assert !isnothing(nz) "No nz specified"
    
    xs = range(xmin, xmax, length=nx)
    ys = range(ymin, ymax, length=ny)
    zs = range(zmin, zmax, length=nz)
    
    X, Y, Z = meshgrid(xs, ys, zs)
    
    Bx, By, Bz = bfield_from_thin_straight_wire(X, Y, Z, p1, p2, current, plot_wire=plot_wire)
    
    dx = (xmax - xmin) / (nx - 1)
    dy = (ymax - ymin) / (ny - 1)
    dz = (zmax - zmin) / (nz - 1)
    
    attrs = Dict(
        "gridOriginOffset" => (xs[1], ys[1], zs[1]),
        "gridSpacing" => (dx, dy, dz),
        "gridSize" => size(Bx),
        "eleAnchorPt" => "center",
        "gridGeometry" => "rectangular",
        "axisLabels" => ("x", "y", "z"),
        "gridLowerBound" => (0, 0, 0),
        "harmonic" => 0,
        "fundamentalFrequency" => 0
    )
    
    components = Dict(
        "magneticField/x" => Bx,
        "magneticField/y" => By,
        "magneticField/z" => Bz
    )
    
    data = Dict("attrs" => attrs, "components" => components)
    
    return FieldMesh(data=data)
end

# Helper function for meshgrid
function meshgrid(x, y, z)
    nx = length(x)
    ny = length(y)
    nz = length(z)
    X = repeat(x, outer=(1, ny, nz))
    Y = repeat(y, outer=(nx, 1, nz))
    Z = repeat(z, outer=(nx, ny, 1))
    return X, Y, Z
end 