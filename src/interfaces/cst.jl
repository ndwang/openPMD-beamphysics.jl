"""
    get_scale(unit)

Returns the scaling factor corresponding to the provided unit.

Parameters
----------
unit : String
    The unit for which the scaling factor is requested.
    Accepted values are:
    - "[mm]" : millimeters
    - "[V/m]" : volts per meter
    - "[A/m]" : amperes per meter

Returns
-------
Float64
    The scaling factor corresponding to the unit.
    - 1e-3 for millimeters ("[mm]")
    - 1 for volts per meter ("[V/m]")
    - mu_0 (vacuum permeability) for amperes per meter ("[A/m]")
"""
function get_scale(unit::String)
    if unit == "[mm]"
        return 1e-3
    elseif unit == "[V/m]"
        return 1.0
    elseif unit == "[A/m]"
        return mu_0
    end
end

"""
    get_vec(x)

Processes the input array `x` to compute key vector parameters.

The function computes the minimum and maximum values of `x`, the difference
between consecutive unique and sorted elements (`dx`), and the number of
unique elements in `x`.

Parameters
----------
x : Array
    An array of numerical values from which to compute the vector parameters.

Returns
-------
xmin : Float64
    The minimum value in `x`.
xmax : Float64
    The maximum value in `x`.
dx : Float64
    The uniform difference between consecutive unique elements in `x`.
    Raises an assertion error if differences are not uniform.
nx : Int64
    The number of unique elements in `x`.
"""
function get_vec(x)
    sx = unique(x)
    nx = length(sx)
    xlist = sort(sx)
    dx = diff(xlist)
    all(dx .â‰ˆ dx[1]) || error("Non-uniform spacing in vector")
    return minimum(x), maximum(x), dx[1], nx
end

"""
    read_cst_ascii_3d_field(filePath, n_header=2)

Parses a 3D field file generated by CST, extracting field data and header information.

The function reads and processes an ASCII file containing 3D electromagnetic field data
(E or H fields) in the form of vectors (x, y, z) followed by field components. The field data
can be either static or time-varying (complex fields) depending on the format.

Parameters
----------
filePath : String
    The full path to the 3D field ASCII file.
n_header : Int, optional
    The number of header lines to skip before reading the field data. Default is 2.

Returns
-------
data : Array
    An array containing the parsed 3D field data. The format of the data depends on
    whether the field is static or time-varying. The array is ordered in Fortran ('F') format.

header_info : Dict
    A dictionary containing extracted information from the file header, such as units and
    field types (E or H field components).
"""
function read_cst_ascii_3d_field(filePath::String, n_header::Int=2)
    # Read header
    header = readline(filePath)
    headers = split(header)
    columns = headers[1:2:end]
    units = headers[2:2:end]

    # Determine field type
    field_columns = unique([c[1:2] for c in columns if startswith(c, "E") || startswith(c, "H")])
    
    if all(startswith.(field_columns, "E"))
        field_type = "electric"
    elseif all(startswith.(field_columns, "H"))
        field_type = "magnetic"
    else
        error("Mixed CST mode not currently supported.")
    end

    # Read data
    dat = readdlm(filePath, skipstart=n_header)

    # Process coordinates
    X = dat[:, 1] .* get_scale(units[1])
    Y = dat[:, 2] .* get_scale(units[2])
    Z = dat[:, 3] .* get_scale(units[3])

    xmin, xmax, dx, nx = get_vec(X)
    ymin, ymax, dy, ny = get_vec(Y)
    zmin, zmax, dz, nz = get_vec(Z)

    shape = (nx, ny, nz)

    # Process field components
    if length(columns) == 9
        # Complex field
        Fx = reshape((dat[:, 4] .- im .* dat[:, 5]) .* get_scale(units[4]), shape)
        Fy = reshape((dat[:, 6] .- im .* dat[:, 7]) .* get_scale(units[5]), shape)
        Fz = reshape((dat[:, 8] .- im .* dat[:, 9]) .* get_scale(units[6]), shape)
    elseif length(columns) == 6
        # Real field
        Fx = reshape(dat[:, 4] .* get_scale(units[4]), shape)
        Fy = reshape(dat[:, 5] .* get_scale(units[5]), shape)
        Fz = reshape(dat[:, 6] .* get_scale(units[6]), shape)
    end

    attrs = Dict{String,Any}(
        "gridOriginOffset" => (xmin, ymin, zmin),
        "gridSpacing" => (dx, dy, dz),
        "gridSize" => (nx, ny, nz)
    )

    components = Dict{String,Array}(
        "$(field_type)Field/x" => Fx,
        "$(field_type)Field/y" => Fy,
        "$(field_type)Field/z" => Fz
    )

    return attrs, components
end

"""
    read_cst_ascii_3d_static_field(ffile)

Parses a complete 3D static real electric or magnetic field from a corresponding CST E or H ASCII file.

Parameters
----------
ffile : String
    Path to the ASCII file containing the real static field data (E-field or H-field) generated by CST.

Returns
-------
Dict
    FieldMesh ready data dict for the static field.
"""
function read_cst_ascii_3d_static_field(ffile::String)
    attrs, components = read_cst_ascii_3d_field(ffile)

    attrs["eleAnchorPt"] = "center"
    attrs["gridGeometry"] = "rectangular"
    attrs["axisLabels"] = ("x", "y", "z")
    attrs["gridLowerBound"] = (0, 0, 0)
    attrs["harmonic"] = 0
    attrs["fundamentalFrequency"] = 0

    return Dict("attrs" => attrs, "components" => components)
end

"""
    read_cst_ascii_3d_complex_fields(efile, hfile, frequency, harmonic=1)

Parses a complete 3D field map from corresponding CST E and H field files for a complex electromagnetic mode.

Parameters
----------
efile : String
    Path to the electric field (E-field) file containing the full complex electromagnetic mode.
hfile : String
    Path to the magnetic field (H-field) file containing the full complex electromagnetic mode.
frequency : Float64
    The frequency of the electromagnetic mode in Hz.
harmonic : Int, optional
    The mode harmonic to be considered. The default is 1 (fundamental harmonic).

Returns
-------
Dict
    FieldMesh style data dict containing the complex fields
"""
function read_cst_ascii_3d_complex_fields(efile::String, hfile::String, frequency::Float64, harmonic::Int=1)
    isfile(efile) || error("Could not find electric field file")
    isfile(hfile) || error("Could not find magnetic field file")

    e_attrs, e_components = read_cst_ascii_3d_field(efile)
    b_attrs, b_components = read_cst_ascii_3d_field(hfile)

    # Merge attributes
    attrs = copy(e_attrs)
    attrs["eleAnchorPt"] = "center"
    attrs["gridGeometry"] = "rectangular"
    attrs["axisLabels"] = ("x", "y", "z")
    attrs["gridLowerBound"] = (0, 0, 0)
    attrs["harmonic"] = harmonic
    attrs["fundamentalFrequency"] = frequency

    # Merge components
    components = merge(e_components, b_components)

    return Dict("attrs" => attrs, "components" => components)
end 